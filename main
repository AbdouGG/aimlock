local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Camera = workspace.CurrentCamera
local TweenService = game:GetService("TweenService")

-- Variables to track FPS
local lastUpdate = tick()
local frameCount = 0

-- Configuration
local Config = {
    WindowName = "Nurk Hub | V1.6.6",
    DiscordInvite = "https://discord.com/invite/8ub8UQNzbT ",
    AimbotKey = Enum.KeyCode.Q,
    ESPColor = Color3.fromRGB(255, 0, 0),
    AimbotSmoothness = 0.5,
    AimbotFOV = 100,
    AimbotTargetPart = "Head",
    FOVColor = Color3.fromRGB(255, 255, 255),
    FOVThickness = 1,
    FOVTransparency = 0.7,
    TeamCheck = false,
    WallCheck = true,
    ESPBoxes = true,
    ESPNames = true,
    ESPDistance = false,
    ESPHealth = false,
    ESPTracer = false,
    MaxESPDistance = 1000,
    PingCompensation = false,
    MaxPingPrediction = 0.15,
    IgnoreDeadPlayers = true,
    MinTrackingSpeed = 0.2,
    MaxTrackingSpeed = 2.0,
    AccelerationWeight = 0.7,
    VelocityHistory = 5,
    TeamColor = Color3.fromRGB(0, 255, 0),
    EnemyColor = Color3.fromRGB(255, 0, 0),
    RainbowFOV = false,
    RainbowESP = false,
    RandomTargetPart = false,
    RandomTargetPartInterval = 0.5 -- NEW: Interval for random part changes
}

-- State
local State = {
    AimbotActive = false,
    TargetPlayer = nil,
    ESPEnabled = false,
    FOVCircle = nil,
    ESPObjects = {},
    VelocityBuffer = {},
    LastTargetPosition = nil,
    LastUpdateTime = tick(),
    RainbowHue = 0,
    CurrentRandomPart = nil,    -- NEW: Stores the currently selected random part
    LastRandomPartUpdate = 0,   -- NEW: Tracks last random part change time
    LastTargetPlayer = nil      -- NEW: Tracks last target for part regeneration
}

-- Create Custom UI
local ScreenGui = Instance.new("ScreenGui")
ScreenGui.Name = "NurkHubUI"
ScreenGui.ResetOnSpawn = false
ScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling

local MainFrame = Instance.new("Frame")
MainFrame.Name = "MainFrame"
MainFrame.Parent = ScreenGui
MainFrame.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
MainFrame.BorderSizePixel = 0
MainFrame.Position = UDim2.new(0.5, -150, 0.5, -200)
MainFrame.Size = UDim2.new(0, 300, 0, 400)
MainFrame.Active = true
MainFrame.Draggable = true

-- Add corner radius
local UICorner = Instance.new("UICorner")
UICorner.CornerRadius = UDim.new(0, 10)
UICorner.Parent = MainFrame

-- Add border
local Border = Instance.new("UIStroke")
Border.Color = Color3.fromRGB(255, 0, 0)
Border.Thickness = 2
Border.Parent = MainFrame

-- Title Bar
local TitleBar = Instance.new("Frame")
TitleBar.Name = "TitleBar"
TitleBar.Parent = MainFrame
TitleBar.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
TitleBar.BorderSizePixel = 0
TitleBar.Size = UDim2.new(1, 0, 0, 40)

local TitleCorner = Instance.new("UICorner")
TitleCorner.CornerRadius = UDim.new(0, 10)
TitleCorner.Parent = TitleBar

-- Title Text
local Title = Instance.new("TextLabel")
Title.Name = "Title"
Title.Parent = TitleBar
Title.BackgroundTransparency = 1
Title.Position = UDim2.new(0, 10, 0, 0)
Title.Size = UDim2.new(1, -50, 1, 0)
Title.Font = Enum.Font.GothamBold
Title.Text = "Nurk Hub"
Title.TextColor3 = Color3.fromRGB(255, 255, 255)
Title.TextSize = 18
Title.TextXAlignment = Enum.TextXAlignment.Left

-- Close Button
local CloseButton = Instance.new("TextButton")
CloseButton.Name = "CloseButton"
CloseButton.Parent = TitleBar
CloseButton.BackgroundColor3 = Color3.fromRGB(200, 0, 0)
CloseButton.BorderSizePixel = 0
CloseButton.Position = UDim2.new(1, -35, 0.5, -12.5)
CloseButton.Size = UDim2.new(0, 25, 0, 25)
CloseButton.Font = Enum.Font.GothamBold
CloseButton.Text = "X"
CloseButton.TextColor3 = Color3.fromRGB(255, 255, 255)
CloseButton.TextSize = 14

local CloseCorner = Instance.new("UICorner")
CloseCorner.CornerRadius = UDim.new(0, 5)
CloseCorner.Parent = CloseButton

-- Tabs Container
local TabsContainer = Instance.new("Frame")
TabsContainer.Name = "TabsContainer"
TabsContainer.Parent = MainFrame
TabsContainer.BackgroundColor3 = Color3.fromRGB(25, 25, 25)
TabsContainer.BorderSizePixel = 0
TabsContainer.Position = UDim2.new(0, 0, 0, 40)
TabsContainer.Size = UDim2.new(1, 0, 0, 40)

local TabsLayout = Instance.new("UIListLayout")
TabsLayout.Parent = TabsContainer
TabsLayout.FillDirection = Enum.FillDirection.Horizontal
TabsLayout.SortOrder = Enum.SortOrder.LayoutOrder
TabsLayout.Padding = UDim.new(0, 0)

-- Content Frame
local ContentFrame = Instance.new("ScrollingFrame")
ContentFrame.Name = "ContentFrame"
ContentFrame.Parent = MainFrame
ContentFrame.BackgroundTransparency = 1
ContentFrame.Position = UDim2.new(0, 10, 0, 90)
ContentFrame.Size = UDim2.new(1, -20, 1, -100)
ContentFrame.ScrollBarThickness = 4
ContentFrame.BorderSizePixel = 0
ContentFrame.CanvasSize = UDim2.new(0, 0, 0, 0)

local ContentLayout = Instance.new("UIListLayout")
ContentLayout.Parent = ContentFrame
ContentLayout.SortOrder = Enum.SortOrder.LayoutOrder
ContentLayout.Padding = UDim.new(0, 8)

-- Function to create section header
local function CreateSection(name, parent)
    local section = Instance.new("TextLabel")
    section.Name = name .. "Section"
    section.Parent = parent
    section.BackgroundTransparency = 1
    section.Size = UDim2.new(1, 0, 0, 25)
    section.Font = Enum.Font.GothamBold
    section.Text = name
    section.TextColor3 = Color3.fromRGB(255, 255, 255)
    section.TextSize = 14
    section.TextXAlignment = Enum.TextXAlignment.Left
    return section
end

-- Tab System
local Tabs = {}
local CurrentTab = nil

local function CreateTab(name)
    local tab = {}
    
    -- Tab Button
    local tabButton = Instance.new("TextButton")
    tabButton.Name = name .. "Tab"
    tabButton.Parent = TabsContainer
    tabButton.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
    tabButton.BorderSizePixel = 0
    tabButton.Size = UDim2.new(1 / 4, 0, 1, 0)
    tabButton.Font = Enum.Font.GothamBold
    tabButton.Text = name
    tabButton.TextColor3 = Color3.fromRGB(150, 150, 150)
    tabButton.TextSize = 12
    
    -- Tab Content Container
    local tabContent = Instance.new("Frame")
    tabContent.Name = name .. "Content"
    tabContent.Parent = ContentFrame
    tabContent.BackgroundTransparency = 1
    tabContent.Size = UDim2.new(1, 0, 0, 0)
    tabContent.Visible = false
    
    local tabLayout = Instance.new("UIListLayout")
    tabLayout.Parent = tabContent
    tabLayout.SortOrder = Enum.SortOrder.LayoutOrder
    tabLayout.Padding = UDim.new(0, 8)
    
    tab.Button = tabButton
    tab.Content = tabContent
    tab.Layout = tabLayout
    
    -- Update canvas size when content changes
    tabLayout:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function()
        if tabContent.Visible then
            ContentFrame.CanvasSize = UDim2.new(0, 0, 0, tabLayout.AbsoluteContentSize.Y + 10)
        end
    end)
    
    -- Tab click handler
    tabButton.MouseButton1Click:Connect(function()
        for _, t in pairs(Tabs) do
            t.Content.Visible = false
            t.Button.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
            t.Button.TextColor3 = Color3.fromRGB(150, 150, 150)
        end
        
        tabContent.Visible = true
        tabButton.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
        tabButton.TextColor3 = Color3.fromRGB(255, 255, 255)
        CurrentTab = tab
        
        -- Update canvas size
        ContentFrame.CanvasSize = UDim2.new(0, 0, 0, tabLayout.AbsoluteContentSize.Y + 10)
    end)
    
    Tabs[name] = tab
    return tab
end

-- Function to create toggle button
local function CreateToggle(name, default, callback, parent)
    local toggleFrame = Instance.new("Frame")
    toggleFrame.Name = name .. "Toggle"
    toggleFrame.Parent = parent
    toggleFrame.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
    toggleFrame.BorderSizePixel = 0
    toggleFrame.Size = UDim2.new(1, 0, 0, 35)
    
    local toggleCorner = Instance.new("UICorner")
    toggleCorner.CornerRadius = UDim.new(0, 5)
    toggleCorner.Parent = toggleFrame
    
    local label = Instance.new("TextLabel")
    label.Parent = toggleFrame
    label.BackgroundTransparency = 1
    label.Position = UDim2.new(0, 10, 0, 0)
    label.Size = UDim2.new(0.7, 0, 1, 0)
    label.Font = Enum.Font.Gotham
    label.Text = name
    label.TextColor3 = Color3.fromRGB(255, 255, 255)
    label.TextSize = 12
    label.TextXAlignment = Enum.TextXAlignment.Left
    
    local button = Instance.new("TextButton")
    button.Parent = toggleFrame
    button.BackgroundColor3 = default and Color3.fromRGB(0, 255, 0) or Color3.fromRGB(255, 0, 0)
    button.BorderSizePixel = 0
    button.Position = UDim2.new(1, -65, 0.5, -12.5)
    button.Size = UDim2.new(0, 55, 0, 25)
    button.Font = Enum.Font.GothamBold
    button.Text = default and "ON" or "OFF"
    button.TextColor3 = Color3.fromRGB(255, 255, 255)
    button.TextSize = 11
    
    local buttonCorner = Instance.new("UICorner")
    buttonCorner.CornerRadius = UDim.new(0, 5)
    buttonCorner.Parent = button
    
    local isEnabled = default
    
    button.MouseButton1Click:Connect(function()
        isEnabled = not isEnabled
        button.Text = isEnabled and "ON" or "OFF"
        button.BackgroundColor3 = isEnabled and Color3.fromRGB(0, 255, 0) or Color3.fromRGB(255, 0, 0)
        callback(isEnabled)
    end)
    
    return toggleFrame
end

-- Function to create slider
local function CreateSlider(name, min, max, default, callback, parent)
    local sliderFrame = Instance.new("Frame")
    sliderFrame.Name = name .. "Slider"
    sliderFrame.Parent = parent
    sliderFrame.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
    sliderFrame.BorderSizePixel = 0
    sliderFrame.Size = UDim2.new(1, 0, 0, 50)
    
    local sliderCorner = Instance.new("UICorner")
    sliderCorner.CornerRadius = UDim.new(0, 5)
    sliderCorner.Parent = sliderFrame
    
    local label = Instance.new("TextLabel")
    label.Parent = sliderFrame
    label.BackgroundTransparency = 1
    label.Position = UDim2.new(0, 10, 0, 5)
    label.Size = UDim2.new(1, -20, 0, 15)
    label.Font = Enum.Font.Gotham
    label.Text = name .. ": " .. default
    label.TextColor3 = Color3.fromRGB(255, 255, 255)
    label.TextSize = 12
    label.TextXAlignment = Enum.TextXAlignment.Left
    
    local sliderBar = Instance.new("Frame")
    sliderBar.Parent = sliderFrame
    sliderBar.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
    sliderBar.BorderSizePixel = 0
    sliderBar.Position = UDim2.new(0, 10, 0, 30)
    sliderBar.Size = UDim2.new(1, -20, 0, 6)
    
    local sliderBarCorner = Instance.new("UICorner")
    sliderBarCorner.CornerRadius = UDim.new(1, 0)
    sliderBarCorner.Parent = sliderBar
    
    local sliderFill = Instance.new("Frame")
    sliderFill.Parent = sliderBar
    sliderFill.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
    sliderFill.BorderSizePixel = 0
    sliderFill.Size = UDim2.new((default - min) / (max - min), 0, 1, 0)
    
    local sliderFillCorner = Instance.new("UICorner")
    sliderFillCorner.CornerRadius = UDim.new(1, 0)
    sliderFillCorner.Parent = sliderFill
    
    local dragging = false
    
    sliderBar.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            dragging = true
        end
    end)
    
    sliderBar.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            dragging = false
        end
    end)
    
    UserInputService.InputChanged:Connect(function(input)
        if dragging and input.UserInputType == Enum.UserInputType.MouseMovement then
            local relativePos = math.clamp((input.Position.X - sliderBar.AbsolutePosition.X) / sliderBar.AbsoluteSize.X, 0, 1)
            local value = min + (max - min) * relativePos
            
            sliderFill.Size = UDim2.new(relativePos, 0, 1, 0)
            label.Text = name .. ": " .. math.floor(value)
            callback(value)
        end
    end)
    
    return sliderFrame
end

-- Function to create info label
local function CreateLabel(text, parent)
    local labelFrame = Instance.new("Frame")
    labelFrame.Parent = parent
    labelFrame.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
    labelFrame.BorderSizePixel = 0
    labelFrame.Size = UDim2.new(1, 0, 0, 30)
    
    local labelCorner = Instance.new("UICorner")
    labelCorner.CornerRadius = UDim.new(0, 5)
    labelCorner.Parent = labelFrame
    
    local label = Instance.new("TextLabel")
    label.Parent = labelFrame
    label.BackgroundTransparency = 1
    label.Size = UDim2.new(1, -20, 1, 0)
    label.Position = UDim2.new(0, 10, 0, 0)
    label.Font = Enum.Font.Gotham
    label.Text = text
    label.TextColor3 = Color3.fromRGB(200, 200, 200)
    label.TextSize = 11
    label.TextXAlignment = Enum.TextXAlignment.Left
    label.TextWrapped = true
    
    return labelFrame, label
end

-- Rainbow color function
local function GetRainbowColor()
    State.RainbowHue = (State.RainbowHue + 0.01) % 1
    return Color3.fromHSV(State.RainbowHue, 1, 1)
end

-- NEW: Get random body part from character
local function GetRandomBodyPart(character)
    local bodyParts = {}
    -- R6 parts
    if character:FindFirstChild("Head") then table.insert(bodyParts, "Head") end
    if character:FindFirstChild("HumanoidRootPart") then table.insert(bodyParts, "HumanoidRootPart") end
    if character:FindFirstChild("Torso") then table.insert(bodyParts, "Torso") end
    if character:FindFirstChild("Left Arm") then table.insert(bodyParts, "Left Arm") end
    if character:FindFirstChild("Right Arm") then table.insert(bodyParts, "Right Arm") end
    if character:FindFirstChild("Left Leg") then table.insert(bodyParts, "Left Leg") end
    if character:FindFirstChild("Right Leg") then table.insert(bodyParts, "Right Leg") end
    
    -- R15 parts
    if character:FindFirstChild("UpperTorso") then table.insert(bodyParts, "UpperTorso") end
    if character:FindFirstChild("LowerTorso") then table.insert(bodyParts, "LowerTorso") end
    if character:FindFirstChild("LeftUpperArm") then table.insert(bodyParts, "LeftUpperArm") end
    if character:FindFirstChild("RightUpperArm") then table.insert(bodyParts, "RightUpperArm") end
    if character:FindFirstChild("LeftLowerArm") then table.insert(bodyParts, "LeftLowerArm") end
    if character:FindFirstChild("RightLowerArm") then table.insert(bodyParts, "RightLowerArm") end
    if character:FindFirstChild("LeftHand") then table.insert(bodyParts, "LeftHand") end
    if character:FindFirstChild("RightHand") then table.insert(bodyParts, "RightHand") end
    if character:FindFirstChild("LeftUpperLeg") then table.insert(bodyParts, "LeftUpperLeg") end
    if character:FindFirstChild("RightUpperLeg") then table.insert(bodyParts, "RightUpperLeg") end
    if character:FindFirstChild("LeftLowerLeg") then table.insert(bodyParts, "LeftLowerLeg") end
    if character:FindFirstChild("RightLowerLeg") then table.insert(bodyParts, "RightLowerLeg") end
    if character:FindFirstChild("LeftFoot") then table.insert(bodyParts, "LeftFoot") end
    if character:FindFirstChild("RightFoot") then table.insert(bodyParts, "RightFoot") end
    
    if #bodyParts > 0 then
        return bodyParts[math.random(1, #bodyParts)]
    end
    return "Head" -- fallback
end

-- Build UI
local AimbotTab = CreateTab("AIMBOT")
local VisualsTab = CreateTab("VISUALS")
local InfoTab = CreateTab("INFO")

-- Aimbot Tab Content
CreateSection("AIMBOT", AimbotTab.Content)
CreateToggle("Aimbot", false, function(value) State.AimbotActive = value end, AimbotTab.Content)
CreateToggle("Team Check", false, function(value) Config.TeamCheck = value end, AimbotTab.Content)
CreateToggle("Wall Check", true, function(value) Config.WallCheck = value end, AimbotTab.Content)
CreateToggle("Ignore Dead", true, function(value) Config.IgnoreDeadPlayers = value end, AimbotTab.Content)

-- NEW: Random Part Toggle
CreateToggle("Random Part", false, function(value) 
    Config.RandomTargetPart = value 
    -- Reset state when toggled
    State.CurrentRandomPart = nil
    State.LastTargetPlayer = nil
    State.LastRandomPartUpdate = 0
end, AimbotTab.Content)

CreateSlider("Smoothness", 0, 100, Config.AimbotSmoothness * 100, function(value)
    Config.AimbotSmoothness = value / 100
end, AimbotTab.Content)

CreateSlider("FOV", 10, 500, Config.AimbotFOV, function(value)
    Config.AimbotFOV = value
    if State.FOVCircle then State.FOVCircle.Radius = value end
end, AimbotTab.Content)

CreateSection("PREDICTION", AimbotTab.Content)
CreateToggle("Ping Compensation", false, function(value) Config.PingCompensation = value end, AimbotTab.Content)

CreateSection("RAINBOW", AimbotTab.Content)
CreateToggle("Rainbow FOV", false, function(value) 
    Config.RainbowFOV = value
    if not value and State.FOVCircle then
        State.FOVCircle.Color = Config.FOVColor
    end
end, AimbotTab.Content)

-- Visuals Tab Content
CreateSection("VISUALS", VisualsTab.Content)
CreateToggle("ESP", false, function(value) State.ESPEnabled = value end, VisualsTab.Content)
CreateToggle("Boxes", true, function(value) Config.ESPBoxes = value end, VisualsTab.Content)
CreateToggle("Names", true, function(value) Config.ESPNames = value end, VisualsTab.Content)
CreateToggle("Distance", false, function(value) Config.ESPDistance = value end, VisualsTab.Content)
CreateToggle("Health", false, function(value) Config.ESPHealth = value end, VisualsTab.Content)
CreateToggle("Tracers", false, function(value) Config.ESPTracer = value end, VisualsTab.Content)

CreateSection("RAINBOW", VisualsTab.Content)
CreateToggle("Rainbow ESP", false, function(value) Config.RainbowESP = value end, VisualsTab.Content)

-- Info Tab Content
CreateSection("INFO", InfoTab.Content)
local targetLabelFrame, targetLabel = CreateLabel("Target: None", InfoTab.Content)
local targetPartLabelFrame, targetPartLabel = CreateLabel("Part: Head", InfoTab.Content)
local fpsLabelFrame, fpsLabel = CreateLabel("FPS: 0", InfoTab.Content)
local pingLabelFrame, pingLabel = CreateLabel("Ping: 0ms", InfoTab.Content)

-- Activate first tab by default
Tabs["AIMBOT"].Button.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
Tabs["AIMBOT"].Button.TextColor3 = Color3.fromRGB(255, 255, 255)
Tabs["AIMBOT"].Content.Visible = true
CurrentTab = Tabs["AIMBOT"]
ContentFrame.CanvasSize = UDim2.new(0, 0, 0, Tabs["AIMBOT"].Layout.AbsoluteContentSize.Y + 10)

-- Close button functionality
CloseButton.MouseButton1Click:Connect(function()
    ScreenGui:Destroy()
end)

-- Parent to CoreGui
if gethui then
    ScreenGui.Parent = gethui()
elseif syn and syn.protect_gui then
    syn.protect_gui(ScreenGui)
    ScreenGui.Parent = game.CoreGui
else
    ScreenGui.Parent = game.CoreGui
end

-- Create Toggle Button (Outside of main frame)
local ToggleButton = Instance.new("TextButton")
ToggleButton.Name = "ToggleButton"
ToggleButton.Parent = ScreenGui
ToggleButton.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
ToggleButton.BorderSizePixel = 0
ToggleButton.Position = UDim2.new(0, 10, 0.5, -35)
ToggleButton.Size = UDim2.new(0, 70, 0, 70)
ToggleButton.Font = Enum.Font.GothamBold
ToggleButton.Text = ""
ToggleButton.TextColor3 = Color3.fromRGB(255, 255, 255)
ToggleButton.TextSize = 18
ToggleButton.ZIndex = 1000
ToggleButton.Active = true

local ToggleCorner = Instance.new("UICorner")
ToggleCorner.CornerRadius = UDim.new(0, 15)
ToggleCorner.Parent = ToggleButton

local ToggleBorder = Instance.new("UIStroke")
ToggleBorder.Color = Color3.fromRGB(255, 255, 255)
ToggleBorder.Thickness = 3
ToggleBorder.Parent = ToggleButton

-- Add gradient effect
local ToggleGradient = Instance.new("UIGradient")
ToggleGradient.Color = ColorSequence.new{
    ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 0, 0)),
    ColorSequenceKeypoint.new(1, Color3.fromRGB(180, 0, 0))
}
ToggleGradient.Rotation = 45
ToggleGradient.Parent = ToggleButton

-- Add text label inside button
local ToggleLabel = Instance.new("TextLabel")
ToggleLabel.Name = "Label"
ToggleLabel.Parent = ToggleButton
ToggleLabel.BackgroundTransparency = 1
ToggleLabel.Size = UDim2.new(1, 0, 0.6, 0)
ToggleLabel.Position = UDim2.new(0, 0, 0.2, 0)
ToggleLabel.Font = Enum.Font.GothamBold
ToggleLabel.Text = "NH"
ToggleLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
ToggleLabel.TextSize = 24
ToggleLabel.TextStrokeTransparency = 0.5
ToggleLabel.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
ToggleLabel.ZIndex = 1001

-- Add status indicator
local StatusIndicator = Instance.new("Frame")
StatusIndicator.Name = "StatusIndicator"
StatusIndicator.Parent = ToggleButton
StatusIndicator.BackgroundColor3 = Color3.fromRGB(0, 255, 0)
StatusIndicator.BorderSizePixel = 0
StatusIndicator.Position = UDim2.new(0.5, -15, 0.75, 0)
StatusIndicator.Size = UDim2.new(0, 30, 0, 8)
StatusIndicator.ZIndex = 1001

local StatusCorner = Instance.new("UICorner")
StatusCorner.CornerRadius = UDim.new(1, 0)
StatusCorner.Parent = StatusIndicator

local StatusLabel = Instance.new("TextLabel")
StatusLabel.Parent = ToggleButton
StatusLabel.BackgroundTransparency = 1
StatusLabel.Size = UDim2.new(1, 0, 0.25, 0)
StatusLabel.Position = UDim2.new(0, 0, 0.75, 0)
StatusLabel.Font = Enum.Font.Gotham
StatusLabel.Text = "OPEN"
StatusLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
StatusLabel.TextSize = 10
StatusLabel.TextStrokeTransparency = 0.5
StatusLabel.ZIndex = 1001

-- Make button draggable
local dragging = false
local dragInput
local dragStart
local startPos

local function update(input)
    local delta = input.Position - dragStart
    ToggleButton.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
end

ToggleButton.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
        dragging = true
        dragStart = input.Position
        startPos = ToggleButton.Position
        
        input.Changed:Connect(function()
            if input.UserInputState == Enum.UserInputState.End then
                dragging = false
            end
        end)
    end
end)

ToggleButton.InputChanged:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
        dragInput = input
    end
end)

UserInputService.InputChanged:Connect(function(input)
    if input == dragInput and dragging then
        update(input)
    end
end)

-- Toggle functionality
local isVisible = true
local clickStartTime = 0
local clickThreshold = 0.15 -- Time in seconds to distinguish between click and drag

ToggleButton.MouseButton1Down:Connect(function()
    clickStartTime = tick()
end)

ToggleButton.MouseButton1Up:Connect(function()
    local clickDuration = tick() - clickStartTime
    
    -- Only toggle if it was a quick click (not a drag)
    if clickDuration < clickThreshold then
        isVisible = not isVisible
        MainFrame.Visible = isVisible
        StatusLabel.Text = isVisible and "OPEN" or "CLOSED"
        
        -- Animate button with smooth transitions
        local colorGoal = {BackgroundColor3 = isVisible and Color3.fromRGB(255, 0, 0) or Color3.fromRGB(80, 80, 80)}
        local sizeGoal = {Size = UDim2.new(0, isVisible and 70 or 60, 0, isVisible and 70 or 60)}
        local indicatorColor = {BackgroundColor3 = isVisible and Color3.fromRGB(0, 255, 0) or Color3.fromRGB(255, 0, 0)}
        
        local colorTween = TweenService:Create(ToggleButton, TweenInfo.new(0.3, Enum.EasingStyle.Back, Enum.EasingDirection.Out), colorGoal)
        local sizeTween = TweenService:Create(ToggleButton, TweenInfo.new(0.3, Enum.EasingStyle.Back, Enum.EasingDirection.Out), sizeGoal)
        local indicatorTween = TweenService:Create(StatusIndicator, TweenInfo.new(0.3), indicatorColor)
        
        colorTween:Play()
        sizeTween:Play()
        indicatorTween:Play()
        
        -- Update gradient
        if isVisible then
            ToggleGradient.Color = ColorSequence.new{
                ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 0, 0)),
                ColorSequenceKeypoint.new(1, Color3.fromRGB(180, 0, 0))
            }
        else
            ToggleGradient.Color = ColorSequence.new{
                ColorSequenceKeypoint.new(0, Color3.fromRGB(80, 80, 80)),
                ColorSequenceKeypoint.new(1, Color3.fromRGB(50, 50, 50))
            }
        end
    end
end)

-- Hover effect
ToggleButton.MouseEnter:Connect(function()
    if not dragging then
        local hoverTween = TweenService:Create(ToggleBorder, TweenInfo.new(0.2), {Thickness = 4})
        hoverTween:Play()
    end
end)

ToggleButton.MouseLeave:Connect(function()
    local hoverTween = TweenService:Create(ToggleBorder, TweenInfo.new(0.2), {Thickness = 3})
    hoverTween:Play()
end)

-- Create FOV Circle
local function CreateFOVCircle()
    State.FOVCircle = Drawing.new("Circle")
    State.FOVCircle.Visible = false
    State.FOVCircle.Radius = Config.AimbotFOV
    State.FOVCircle.Color = Config.FOVColor
    State.FOVCircle.Thickness = Config.FOVThickness
    State.FOVCircle.Transparency = Config.FOVTransparency
    State.FOVCircle.Filled = false
    State.FOVCircle.NumSides = 50
end

-- Update FOV Circle
local function UpdateFOVCircle()
    if State.FOVCircle then
        State.FOVCircle.Visible = State.AimbotActive
        State.FOVCircle.Position = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
        
        -- Apply rainbow color if enabled
        if Config.RainbowFOV then
            State.FOVCircle.Color = GetRainbowColor()
        end
    end
end

-- Utility Functions
local function UpdateVelocityBuffer(currentVelocity)
    table.insert(State.VelocityBuffer, currentVelocity)
    if #State.VelocityBuffer > Config.VelocityHistory then
        table.remove(State.VelocityBuffer, 1)
    end
end

local function CalculateAcceleration(targetPart)
    if not State.LastTargetPosition then
        State.LastTargetPosition = targetPart.Position
        return Vector3.new(0, 0, 0)
    end
    
    local currentTime = tick()
    local deltaTime = currentTime - State.LastUpdateTime
    local currentVelocity = targetPart.Velocity
    
    local acceleration = (currentVelocity - (State.VelocityBuffer[#State.VelocityBuffer] or Vector3.new(0, 0, 0))) / deltaTime
    
    State.LastTargetPosition = targetPart.Position
    State.LastUpdateTime = currentTime
    
    return acceleration
end

local function CalculateTrackingSpeed(targetVelocity, acceleration)
    local velocityMagnitude = targetVelocity.Magnitude
    local baseSpeed = math.clamp(velocityMagnitude / 50, Config.MinTrackingSpeed, Config.MaxTrackingSpeed)
    
    local accelerationMagnitude = acceleration.Magnitude
    local accelerationFactor = math.clamp(accelerationMagnitude / 100, 0, 1) * Config.AccelerationWeight
    
    local finalSpeed = baseSpeed * (1 + accelerationFactor)
    
    return math.clamp(finalSpeed, Config.MinTrackingSpeed, Config.MaxTrackingSpeed)
end

local function GetPlayerPing()
    local Stats = game:GetService("Stats")
    return Stats.Network.ServerStatsItem["Data Ping"]:GetValue() / 1000
end

local function IsVisible(targetPart)
    local origin = Camera.CFrame.Position
    local direction = (targetPart.Position - origin).Unit
    local raycastParams = RaycastParams.new()
    raycastParams.FilterDescendantsInstances = {LocalPlayer.Character}
    raycastParams.FilterType = Enum.RaycastFilterType.Blacklist

    local raycastResult = workspace:Raycast(origin, direction * 1000, raycastParams)
    return raycastResult and raycastResult.Instance:IsDescendantOf(targetPart.Parent)
end

local function GetNearestPlayerInFOV()
    local nearestDistance, nearestPlayer = math.huge, nil
    local screenCenter = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)

    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("Humanoid") then
            local humanoid = player.Character:FindFirstChild("Humanoid")
            if humanoid and (not Config.IgnoreDeadPlayers or humanoid.Health > 0) then
                if not Config.TeamCheck or player.Team ~= LocalPlayer.Team then
                    
                    -- Determine which part to check for this player (check Head for target acquisition)
                    local partToCheck = Config.RandomTargetPart and "Head" or Config.AimbotTargetPart
                    
                    local targetPart = player.Character:FindFirstChild(partToCheck)
                    if targetPart then
                        local screenPos, onScreen = Camera:WorldToScreenPoint(targetPart.Position)
                        
                        if onScreen then
                            local distanceFromCenter = (Vector2.new(screenPos.X, screenPos.Y) - screenCenter).Magnitude
                            
                            if distanceFromCenter <= Config.AimbotFOV then
                                local distance = (targetPart.Position - Camera.CFrame.Position).Magnitude
                                if distance < nearestDistance then
                                    if not Config.WallCheck or IsVisible(targetPart) then
                                        nearestDistance, nearestPlayer = distance, player
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end
    end
    return nearestPlayer
end

-- ESP Functions
local function CreateESPObject(player)
    local esp = {}
    
    esp.Box = Drawing.new("Square")
    esp.Box.Thickness = 1
    esp.Box.Filled = false
    esp.Box.Color = Config.ESPColor
    esp.Box.Visible = false

    esp.Name = Drawing.new("Text")
    esp.Name.Center = true
    esp.Name.Outline = true
    esp.Name.Color = Config.ESPColor
    esp.Name.Size = 14
    esp.Name.Visible = false

    esp.Distance = Drawing.new("Text")
    esp.Distance.Center = true
    esp.Distance.Outline = true
    esp.Distance.Color = Config.ESPColor
    esp.Distance.Size = 14
    esp.Distance.Visible = false

    esp.Health = Drawing.new("Text")
    esp.Health.Center = true
    esp.Health.Outline = true
    esp.Health.Color = Config.ESPColor
    esp.Health.Size = 14
    esp.Health.Visible = false

    esp.Tracer = Drawing.new("Line")
    esp.Tracer.Thickness = 1
    esp.Tracer.Color = Config.ESPColor
    esp.Tracer.Visible = false

    State.ESPObjects[player] = esp
end

local function RemoveESPObject(player)
    local esp = State.ESPObjects[player]
    if esp then
        for _, object in pairs(esp) do
            object:Remove()
        end
        State.ESPObjects[player] = nil
    end
end

local function UpdateESP()
    for player, esp in pairs(State.ESPObjects) do
        if player.Character and player.Character:FindFirstChild("HumanoidRootPart") and player.Character:FindFirstChild("Humanoid") then
            local hrp = player.Character.HumanoidRootPart
            local humanoid = player.Character.Humanoid
            local vector, onScreen = Camera:WorldToViewportPoint(hrp.Position)
            local distance = (hrp.Position - Camera.CFrame.Position).Magnitude

            local espColor
            if Config.RainbowESP then
                espColor = GetRainbowColor()
            elseif Config.TeamCheck then
                espColor = (player.Team == LocalPlayer.Team) and Config.TeamColor or Config.EnemyColor
            else
                espColor = Config.EnemyColor
            end

            if onScreen and distance <= Config.MaxESPDistance and State.ESPEnabled then
                if Config.ESPBoxes then
                    local rootPart = player.Character.HumanoidRootPart
                    local head = player.Character.Head
                    local rootPos = Camera:WorldToViewportPoint(rootPart.Position)
                    local headPos = Camera:WorldToViewportPoint(head.Position + Vector3.new(0, 0.5, 0))
                    local legPos = Camera:WorldToViewportPoint(rootPart.Position - Vector3.new(0, 3, 0))

                    esp.Box.Size = Vector2.new(2350 / rootPos.Z, headPos.Y - legPos.Y)
                    esp.Box.Position = Vector2.new(rootPos.X - esp.Box.Size.X / 2, rootPos.Y - esp.Box.Size.Y / 2)
                    esp.Box.Color = espColor
                    esp.Box.Visible = true
                else
                    esp.Box.Visible = false
                end

                if Config.ESPNames then
                    esp.Name.Text = player.Name
                    esp.Name.Position = Vector2.new(vector.X, vector.Y - 40)
                    esp.Name.Color = espColor
                    esp.Name.Visible = true
                else
                    esp.Name.Visible = false
                end

                if Config.ESPDistance then
                    esp.Distance.Text = string.format("%.0f studs", distance)
                    esp.Distance.Position = Vector2.new(vector.X, vector.Y + 40)
                    esp.Distance.Color = espColor
                    esp.Distance.Visible = true
                else
                    esp.Distance.Visible = false
                end

                if Config.ESPHealth then
                    esp.Health.Text = string.format("%.0f HP", humanoid.Health)
                    esp.Health.Position = Vector2.new(vector.X, vector.Y + 60)
                    esp.Health.Color = espColor
                    esp.Health.Visible = true
                else
                    esp.Health.Visible = false
                end

                if Config.ESPTracer then
                    esp.Tracer.From = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y)
                    esp.Tracer.To = Vector2.new(vector.X, vector.Y)
                    esp.Tracer.Color = espColor
                    esp.Tracer.Visible = true
                else
                    esp.Tracer.Visible = false
                end
            else
                for _, object in pairs(esp) do
                    object.Visible = false
                end
            end
        else
            for _, object in pairs(esp) do
                object.Visible = false
            end
        end
    end
end

local function UpdateFPS()
    frameCount = frameCount + 1
    local currentTime = tick()
    local elapsed = currentTime - lastUpdate
    
    if elapsed >= 1 then
        local currentFPS = math.floor(frameCount / elapsed)
        fpsLabel.Text = "FPS: " .. currentFPS
        frameCount = 0
        lastUpdate = currentTime
    end
end

local function UpdatePing()
    local Stats = game:GetService("Stats")
    local currentPing = Stats.Network.ServerStatsItem["Data Ping"]:GetValue()
    pingLabel.Text = "Ping: " .. math.floor(currentPing) .. "ms"
end

-- Main Logic
CreateFOVCircle()

RunService.RenderStepped:Connect(function()
    UpdateFOVCircle()
    UpdateESP()
    UpdatePing()
    UpdateFPS()
    
    if State.AimbotActive then
        State.TargetPlayer = GetNearestPlayerInFOV()
        if State.TargetPlayer then
            targetLabel.Text = "Target: " .. State.TargetPlayer.Name
            
            -- Determine which part to aim at
            local targetPartName = Config.AimbotTargetPart
            
            if Config.RandomTargetPart then
                -- NEW: Update random part every 0.25 seconds or when target changes
                local currentTime = tick()
                if State.TargetPlayer ~= State.LastTargetPlayer or 
                   (currentTime - State.LastRandomPartUpdate >= Config.RandomTargetPartInterval) then
                    State.CurrentRandomPart = GetRandomBodyPart(State.TargetPlayer.Character)
                    State.LastRandomPartUpdate = currentTime
                    State.LastTargetPlayer = State.TargetPlayer
                end
                targetPartName = State.CurrentRandomPart or Config.AimbotTargetPart
            end
            
            -- Update target part display
            targetPartLabel.Text = "Part: " .. targetPartName
            
            local targetPart = State.TargetPlayer.Character:FindFirstChild(targetPartName)
            if targetPart then
                local targetPos = targetPart.Position
                local targetVel = targetPart.Velocity
                
                UpdateVelocityBuffer(targetVel)
                local acceleration = CalculateAcceleration(targetPart)
                local trackingSpeed = CalculateTrackingSpeed(targetVel, acceleration)
                
                local predictionTime = Config.PingCompensation and math.min(GetPlayerPing(), Config.MaxPingPrediction) or 0
                
                local gravityCompensation = Vector3.new(0, 0, 0)
                if targetPartName == "HumanoidRootPart" then
                    local gravity = workspace.Gravity
                    gravityCompensation = Vector3.new(0, -0.5 * gravity * predictionTime * predictionTime, 0)
                end
                
                local predictedPos = targetPos + 
                                   (targetVel * predictionTime) + 
                                   (acceleration * predictionTime * predictionTime * 0.5) + 
                                   gravityCompensation
                
                local randomOffset = Vector3.new(
                    math.random(-5, 5) / 100,
                    math.random(-5, 5) / 100,
                    math.random(-5, 5) / 100
                )
                predictedPos = predictedPos + randomOffset
                
                local cameraPosition = Camera.CFrame.Position
                local lookVector = (predictedPos - cameraPosition).Unit
                local targetCFrame = CFrame.new(cameraPosition, cameraPosition + lookVector)
                
                local distance = (targetPos - cameraPosition).Magnitude
                local dynamicSmoothness = math.min(1, Config.AimbotSmoothness / trackingSpeed)
                
                Camera.CFrame = Camera.CFrame:Lerp(targetCFrame, dynamicSmoothness)
            end
        else
            targetLabel.Text = "Target: None"
            targetPartLabel.Text = "Part: " .. (Config.RandomTargetPart and "Random" or Config.AimbotTargetPart)
            State.LastTargetPosition = nil
            State.VelocityBuffer = {}
            -- Reset random part state when no target
            State.CurrentRandomPart = nil
            State.LastTargetPlayer = nil
        end
    else
        targetLabel.Text = "Target: None"
        targetPartLabel.Text = "Part: " .. (Config.RandomTargetPart and "Random" or Config.AimbotTargetPart)
        -- Reset random part state when aimbot is inactive
        State.CurrentRandomPart = nil
        State.LastTargetPlayer = nil
    end
end)

UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if not gameProcessed and input.KeyCode == Config.AimbotKey then
        State.AimbotActive = not State.AimbotActive
    end
end)

Players.PlayerAdded:Connect(function(player)
    CreateESPObject(player)
end)

Players.PlayerRemoving:Connect(function(player)
    RemoveESPObject(player)
end)

for _, player in ipairs(Players:GetPlayers()) do
    if player ~= LocalPlayer then
        CreateESPObject(player)
    end
end

print("Nurk Hub loaded successfully!")
